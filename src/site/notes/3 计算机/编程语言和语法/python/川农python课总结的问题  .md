---
{"dg-publish":true,"permalink":"/3 计算机/编程语言和语法/python/川农python课总结的问题  /","title":"川农python课总结的问题  "}
---


1.  Python 深浅拷贝  
Python 视图与原数据分别变化后 ，是否会对另一方影响（拷贝和视图）

深拷贝：=

浅拷贝：.copy()

2.  实参和形参？  
实参：除了形式参数以外的参数

形参：定义函数的时候，函数括号里那个东西。形参会提示你函数需要的输入。

3.  列表推导式

4.  Python 局部变量与全局变量：  
函数内部定义的都是局部变量，使用的默认是局部变量。因此出现与函数外部相同的变量名称时，他会定义一个新的局部变量完成操作（如果出现自己定义新的变量会出错的情况，且只是引用而不改变数值，他会直接引用全局变量【for I in range(x) 会直接引用 x，但 x=2\*x 会报错。】）。若想使用全局变量，可用 global 把后面的名字变成全局变量，在函数内部使用。

函数外部定义的都是全局变量，使用的都是全局变量。

局部变量只能在函数内部使用，想在函数外使用就用 global 变成全局变量。

全局变量可在外部直接使用，也可在函数内部使用。在内部需要用 global 把函数内部的局部变量变成全局变量。（但实际上“局部变量为组合数据类型且未创建，等同于全局变量”因此有时可以直接引用，有时必须声明。）

5.  以下程序的输出结果是：  
    dat=\[‘1’, ‘2’, ‘3’, ‘0’, ‘0’, ‘0’\]  
    for item in dat:  
    if item == ‘0’:  
    dat.remove(item)  
    print(dat)  
A、 \[‘1’, ‘2’, ‘3’\]

B、 \[‘1’, ‘2’, ‘3’, ‘0’, ‘0’ \]

C、 \[‘1’, ‘2’, ‘3’, ‘0’, ‘0’, ‘0’\]

D、 \[‘1’, ‘2’, ‘3’, ‘0’\]

正确答案： D、

原因：<https://www.cnblogs.com/lipx9527/p/9450819.html>

就是：1 列表的 for 循环是通过下标的索引完成的 2 删除过程会直接删除列表中的第一次出现的‘0’，而不是正在访问的’0‘（这一点此题没有体现）

6.  将参数传递给函数过程中，arg（普通参数），\*args（参数名字前面加个\*），\*\*kargs（参数名字前面加两个\*）分别有什么共同和区别？  
答：

共同：这三个都是要输入函数的参数的名称（参数名称不包括\*）。在定义函数时，如果括号中是（arg，\*args，\*\*kargs），意味着该函数需要三个参数；在使用函数时，如果括号中是（arg，\*args，\*\*kargs），意味着我们向函数中传递了三个参数 arg，args，kargs。

不同：这三个参数代表的数据类型不一样。Arg：普通参数。\*args：可变个数参数，可输入‘\*+ 一个列表‘或输入多个参数。\*\*args：字典参数，可输入‘\*\*+ 一个字典’或输入多个键值对。

\* 说明：当定义函数时，有多个普通参数时，调用函数（函数实参）可直接输入\*args 或者\*\*kwargs

例子如下：

def test(arg1, arg2, arg3):

print("arg1", arg1)

print("arg2", arg2)

print("arg3", arg3)

\# 使用\*args

args = (1, 2, 3)

test(\*args)

\# 使用\*\*kargs

kargs = {"arg3": 3, "arg2": 2, "arg1": 1}

test(\*\*kargs)

7.  参数传递顺序：必选参数 默认参数 可变参数 关键字参数

8.  Conda 、pip、anaconda 里的 pip 区别：  
答：

（1）、conda 下载到 anaconda3 文件夹下的 lib 里的 site-pkgs 里（虚拟环境下载在虚拟环境的 lib 里的 site-pkgs 里）并且安装包也复制在 anaconda3 下的 pkgs 里，方便下次直接安装。

（2）conda 环境里的 pip 下载到 anaconda3 下的 lib 的 site-pkgs 里，并且安装包也被复制在 anaconda3 下的 pkgs 里。

（3）python 自带的 pip 下载到自己文件夹下的 lib 里的 site-packages 里（如果默认安装会在 C 盘 appdata 、rome 、python 里。）

9.  环境变量的设置：  
右键计算机，属性，高级设置，环境变量，下面的系统框里，选 path 加新的，选某个东西，加入。Py 和。Pym 就可以了。

10. python 的卸载：  
卸载完之后，python 仍然可以重装而保留库，前提是得是一个版本的，如果装新版本，库就在那里放着用不了了。

11. 如果出现 pip 用不了的情况，有可能是上一个 pip 没有卸载，而 python 卸载了的缘故。

12. python -m 命令有什么用？  
命令行执行.py 文件时有两种加载方式：

python xxx.py 与 python -m xxx。

这是两种加载 py 文件的方式：

前者叫做直接运行，此时脚本的\_\_name\_\_ 为 'main'；

后者把模块当作脚本来启动，相当于 import，此时脚本的\_\_name\_\_ 为 'xxx'。这种启动方式时最好不要带后缀.py。

不同的加载 py 文件的方式，主要是影响 sys.path 这个属性。sys.path 是一个 list，是当前 Python 解析器运行的环境，Python 解析器会在这些目录下去寻找依赖库。python 导入文件或模块时默认会先在 sys.path 里找其的路径。

13. 如何一行输入多个值？  
字符串：a,b=input().split()

整数：a,b=map(int,input().split())

14. Eval 和 int 的区别？

15. Python、Anaconda 的卸载是否会删除相关的包，conda 虚拟环境呢？  
Python 卸载后，相关的包会被储存在原位置

Anaconda 卸载后虚拟环境就没有了，相关的包不知道。

16. conda 环境的可用包有哪些？  
anaconda 里的 pip 安装的包、conda 安装的包不知道 idle 能不能用

conda 环境可以使用自己安装的包（在 lib 的 site-packages），也会使用 python 的 pip 安装的包（被复制到了 pkgs 里，pkgs 里其他的包也可能被使用），且会优先使用 python 自带 pip 安装的包。（当时的 ImportError: cannot import name 'PILLOW_VERSION' from 'PIL' 的时候，在 conda 里降版本还是不行，因为它用的是我的 python3.7 里面的包）

17. 软连接？

18. 装包方法：  
Python 环境：1.pip install 2.easy install 3.pycharm 4.wheel 安装

Conda 环境：1.conda install 2.pip install 3.easy install 4.pycharm 5.wheel 安装

19. Python 类（class）有什么功能？  
类可以描述一批具有相同特征的整体，展现他们整体性的属性和方法。使用时，可以通过类的实例化实现对信息的**封装。**

通过**继承**，形成多个类构成的的网络。

**多态**：同一种事物的多种形态，动物分为人类，猪类（在定义角度）。**多态性**：想说调用一个函数两次，参数不同，但这两次实际上执行了两个函数。（就好像动物都会叫，假设猪叫和人叫是两个函数，再设计一个函数让猪或者人作为参数，输入人，就执行人叫函数，输入猪，就执行猪叫函数。我们说这个设计的函数具有多态性）

20. Python 的面向对象 class 里的所有变量和方法？  
<https://blog.csdn.net/weixin_30700977/article/details/99480271>

类里面的所有构成成分都是变量和方法（类外面管方法叫函数）

类内部变量：

（1）**类变量**：类内部通过 xxx=???直接定义的变量。在本类的方法中通过 self.xxx 进行访问（定义方法时括号里是 self 和形参，在那里访问不了变量），在本类中可以直接访问。

（2）**实例变量**：类内部通过 self.xxx=???定义的变量。这种定义的语句都写在类的方法中。除了\_\_init\_\_ 和\_\_del\_\_ 这两个方法以外，显然只有手动执行了相应方法，实例变量才算定义成功。

（3）**特别说明 self**：类内部的 self 代表类本身\类的实例化对象本身。self 一般只出现在每一个方法的括号里（类的方法必须有 self）以及每一个方法的语句里（self.xxx 就表示类内部的 xxx）。

（4）**实例方法**：像定义函数一样定义方法，括号里要有 self。语句中若想访问其他方法和类变量，注意写为 self.xxx 或 self.xxx()。

（5）**类方法**：就是在定义方法前，加了@classmethod。方法的参数要包括 cls 而没有 self；通过 cls.xxx 的方式访问类中的类变量和类方法和静态方法；通过先实例化 xxx=cls()，再 xxx.???的方式访问类中的实例变量和实例方法。进而，类方法在类的外面可以直接使用而不用实例化。

（6）**静态方法**：就是在定义方法前，加了@staticmethod。方法的参数不必要。通过类名.xxx 的方式访问类变量类方法和静态方法；通过先实例化 xxx=类名 ()，再 xxx.???的方式访问类中的实例变量和实例方法。进而，类方法在类的外面可以直接使用二不用实例化。（类方法静态方法区别在 cls 和类名。）

（7）**属性方法**：就是在定义方法前，加了@property。方法无法传参，但括号里要有 self。其他地方=实例方法。但类内类外调用属性方法时，当作变量调用，不写括号。

（8）**构造函数和析构函数**：

构造函数\_\_init\_\_，实例化类后，自动调用该方法。（如果\_\_init\_\_ 中定义了 name。在函数外直接访问类方法时，假设类方法直接调用了 cls.name，就会报错，因为类没有实例化，\_\_init\_\_ 就不会被执行。）

析构函数\_\_del\_\_,类被销毁后，自动执行该方法。

21. 类里面和类外面语法有什么相同或不同？  
假如在类里写了一句 print(”hello world!”)，那么即使不实例化类，代码也会执行,写在类里的代码就像写在外面了一样。

22. 调用类里面的函数和变量和调用类外面的有什么不同？  
调用类里：一般要实例化，然后同过 xxx.???访问。

进制转化

n 进制转 10 进制

int('1101',2)

int('0o226',8)

int('0x96',16)

n 进制转 2 进制

bin(98)

bin(0o45)

bin(0x56)

n 进制转 8 进制

oct()

n 进制转 16 进制

hex()

try-except-else-finally 语句

try: 可能出错的语句

except ...Error: 出了...错后执行的语句

else: except 都没有被执行后，执行的语句

finally: 所有语句执行完后执行的语句，且无论程序是否被中断，都会执行完。